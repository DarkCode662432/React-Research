# OverView:
## Topics to Cover:
  - The Evolution of the Web: Tracing the history and development of web technologies.
  - The Rendering Process in the Past: Exploring how web documents were displayed in earlier times.
  - Problem-Solving with React: Understanding the issues that React addresses in web development.
  - Benefits of Framework Utilization: Exploring the advantages of using a framework in web development.
  - Framework vs. Library: Distinguishing between a framework and a library and their respective roles.
  - Understanding React's Inner Workings: Delving into the working principles of React.
  - Client-Side vs. Server-Side: Differentiating between client-side and server-side in web applications.
  - Advantages of Client-Side Development: Exploring the reasons for using client-side technologies.
  - Advantages of Server-Side Development: Understanding the benefits of server-side technologies.
  - React's Rendering Mechanism: Explaining the concept of rendering in React.
  - The Document Object Model (DOM): Defining the DOM and its significance in web development.
  - The Virtual DOM: Understanding the concept of the virtual DOM in React.
  - Pros and Cons of the Virtual DOM: Evaluating the advantages and disadvantages of the virtual DOM.
  - Enhancing the Virtual DOM: Investigating potential improvements to the virtual DOM based on research and perspectives.
  - React vs. jQuery: Highlighting the differences between React and jQuery.
## Bonus Points 💯:
  - React for Multi-Platforms: Exploring the capabilities of React in developing applications for various platforms.
  - Beyond the Browser: Understanding how React functions on platforms other than web browsers.

# Topics: 
1. ## The Exciting Evolution of the Web!
  ### **Brace yourself for an exhilarating journey through the history and evolution of web development, where innovation knows no bounds!**
  ### Content:

  1. Late 1980s - The Birth of the Web: Step into a world of groundbreaking possibilities as we meet the brilliant British computer scientist, Tim Berners-Lee, who gave birth to the World Wide Web. Witness the inception of a revolutionary concept that would change the course of human history.

  2. 1991 - HTML Takes the Stage: Experience the dawn of a new era with the birth of HTML (Hyper Text Markup Language). Discover how this fundamental language became the backbone of the web, empowering developers to structure documents with hyperlinks and unlock the true potential of interconnectedness.

  3. Mid-1990s - Unleashing Dynamic Content: Feel the thrill of the mid-1990s as web browsers take center stage. Join the battle of the titans, as Netscape Navigator and Microsoft's Internet Explorer compete in the legendary "Browser Wars." Witness the game-changing introduction of JavaScript (JS), bringing dynamic content and interactivity to web pages like never before.

  4. Late 1990s - CSS Steals the Show: Prepare to be mesmerized by the emergence of CSS (Cascading Style Sheets). Marvel at the World Wide Web Consortium's (W3C) stroke of genius, as CSS revolutionizes web design by separating content from presentation. Experience the newfound flexibility and standardization that breathes life into websites.

  5. Late 1990s - Early 2000s - The Dot-Com Bubble Bursts: Hold on tight as we navigate the exhilarating highs and devastating lows of the dot-com bubble. Witness the birth of Web 2.0, a game-changing era that celebrates user-generated content, social media, and the advent of technologies like AJAX that power dynamic web applications.

  6. Mid-2000s - Mobile Revolution Unleashed: Brace yourself for a seismic shift in web development as mobile devices take the world by storm. Explore the challenges and triumphs as responsive web design emerges, ensuring seamless adaptability across various screen sizes and orientations.

  7. 2000s - Present - Enter the Era of Frameworks and Libraries: Discover a treasure trove of tools that empower developers to conquer the ever-growing complexity of web development. Immerse yourself in the world of popular frameworks and libraries like jQuery, Angular, React, and Vue.js. Experience the magic as these tools streamline development, promote best practices, and pave the way for captivating interactive web applications.

  8. 2010s - Present - Unleashing Full-Stack Development: Embark on a thrilling adventure as the concept of full-stack development takes center stage. Witness the rise of developers skilled in both front-end (client-side) and back-end (server-side) technologies. Experience the synergy of DevOps practices, bridging the gap between development and IT operations to foster a holistic approach to web development. Dive into the realm of web accessibility, where creating inclusive web experiences and the rise of Progressive Web Apps (PWAs) takes center stage, offering offline capabilities and a more app-like experience on the web.

  9. Modern Web Development - Embracing the Future: Hold your breath as web development ventures into uncharted territory. Witness the convergence of AI and machine learning, as developers unleash personalized user experiences that defy imagination. Brace yourself for the mind-bending impact of Virtual Reality (VR) and Augmented Reality (AR) on web development, offering immersive experiences that push the boundaries of what's possible. Stay on the edge of your seat as developers explore the latest technologies and standards, propelling the field forward at an unprecedented pace.

  ### Resource:

  Inject some extra excitement into your journey by exploring the exhilarating insights shared by the visionary Abhishek Tiwari himself.[**Check out the full article here ↗**](https://medium.com/@Abhishek-Tiwari/the-history-and-evolution-of-web-development-from-html-to-the-modern-web-982e3f90e891#:~:text=The%20History%20and%20Evolution%20of%20Web%20Development%3A%20From,Full-Stack%20Development%20%282010s%20-%20Present%29%20%D8%A7%D9%84%D9%85%D8%B2%D9%8A%D8%AF%20%D9%85%D9%86%20%D8%A7%D9%84%D8%B9%D9%86%D8%A7%D8%B5%D8%B1). Prepare to be inspired and captivated by the thrilling tale of web development's evolution!

2. ## The Rendering Process in the Past 
  ### Content:

  1. Rewind to the early days of the internet, where the foundations of website development thrived on the power of Server-Side Rendering (SSR) technologies like PHP. SSR took center stage as the server meticulously generated and delivered HTML to the client's browser for rendering. Simple websites without the need for dynamic updates or intricate user interactions found solace in this approach.

  2. SSR held a secret ingredient that empowered websites to transcend device limitations. Regardless of limited processing power or sluggish internet connections, websites flourished. The server shouldered the burden of HTML generation, ensuring that even devices with modest capabilities could load pages swiftly.

  ![SSR](https://miro.medium.com/max/7680/1*ZfWcvvaK6fO_HpjEq4mGGQ.png)

  3. Let's uncover the allure of SSR with its remarkable benefits:

  - Swift page loads: SSR's prowess allowed the server to transmit complete HTML pages to clients, leading to lightning-fast load times compared to Client-Side Rendering (CSR).

  - SEO superiority: With the server taking charge of generating the entire HTML page, search engine crawlers reveled in the ease of indexing, enhancing a website's visibility on search engine result pages.

  - Simplicity for static sites: SSR's charm lies in its suitability for websites that boast simplicity, devoid of complex interactions or dynamic content.

  4. However, SSR had its limitations, revealing its vulnerable side:

  - Interactive restrictions: As most rendering occurred on the server side, SSR proved less ideal for websites demanding frequent updates or intricate user interactions.

  - Resource hunger: The server bore the brunt of SSR's resource-intensive nature, especially when dealing with an abundance of pages or concurrent users.

  ### Delve Deeper with this Resource:

  Feel free to explore the fascinating journey of content rendering on websites in the past by visiting [this GitHub resource ↗.](https://gist.github.com/rasheedsaqib/be2084922356df4d3d61500e66177e58)


3. ## The issues that React addresses in web development && Benefits of Framework Utilization
  ### Brace yourself for an incredible journey through the world of React, the game-changer in web development. Get ready to witness the triumphs and challenges of this revolutionary technology.
  ### What Lies Ahead?

  - To truly grasp the essence of React, we must first understand how web applications are crafted. Traditionally, PHP and Java held the reins, but React swooped in to steal the spotlight. With its dynamic functionalities and unparalleled power, React has become the go-to choice for modern web applications. Even industry giants like Facebook, Instagram, and Dropbox have embraced its potential.

  ### Content:
  - #### Harnessing the Strengths of React:

  1. Component-based Marvel: React's core lies in its component-based architecture. Gone are the days of rewriting code for repetitive elements. With React, you can create reusable components that can be effortlessly integrated anywhere within your application. Say goodbye to redundancy and hello to efficiency!

  2. The Power of Community: React boasts an expansive and vibrant community. Countless developers have joined forces to tackle challenges, constantly updating and refining the library. With such strong support, finding solutions to any roadblocks becomes a breeze. Embrace the collective wisdom of the community and unleash your full potential.

  3. The Path to Enlightenment: React may seem daunting at first, but fear not! Once you grasp the fundamental components and their inner workings, the entire process becomes remarkably straightforward. Even the most intricate applications can be crafted using React's elegant simplicity. Remember, while React is easy to learn, becoming a true master requires dedication and practice.

  4. Mobile Marvels with React Native: As the demand for mobile applications soars, React comes to the rescue. Enter React Native, a technology that empowers you to develop mobile apps for both Android and iOS platforms. By leveraging similar methodologies as React, you can seamlessly transition into the realm of mobile application development. Embrace the power of React and conquer the mobile landscape.

  5. Scaling the Heights: React's true potential shines when combined with other libraries. Its versatility allows for seamless integration with a myriad of functionalities and features. Remember, React is not just a framework; it's a library that can be customized to suit your development needs. Unlock limitless possibilities by harnessing the power of React in conjunction with other libraries

  - #### Navigating the Challenges:
    ##### While React offers immense benefits, it's important to be aware of the challenges that lie ahead:

  1. Ascending the Learning Curve: React's learning curve may appear steep, but fear not! Building a solid foundation is just the beginning. As you embark on your React journey, you may encounter moments where something seems amiss or additional functionalities are required. Mastery takes time and practice, but the rewards are well worth the effort.

  2. Frontend Focused: Remember, React is primarily a frontend technology. To delve into the backend realm, additional technologies like Express or React frameworks like Next.js come into play. React thrives in the realm of single-page and static applications. Embrace its strengths when crafting these types of projects.

  3. The SEO Conundrum: SEO-friendliness poses a challenge for React. Web applications such as blog sites struggle to harness React's full potential, leading to lower search engine rankings. When rendering React applications, JavaScript processing becomes necessary, hindering crawlers and search engine bots from accessing crucial data. Fear not, for Next.js comes to the rescue with server-side rendering, solving this SEO puzzle.

  4. Embracing Change: React is constantly evolving, with bugs and issues being addressed and fixed regularly. This means a flurry of updates may come your way within a short span of time. Stay vigilant, keep up with the changes, and adapt your applications accordingly. Remember, growth and evolution are the hallmarks of progress.

  ### Resources:
For more articles on web development, dive into the realm of [Javascript ↗](https://javascript.plainenglish.io/pros-and-cons-of-using-react-in-web-development-ffb81a6235b9) and unlock the potential of your creations.

4. ## The Epic Battle: Framework vs. Library 
  ### Unleashing the Power of Code!🦾😁
  ### Content:
  * Are you ready to dive into the thrilling world of web development? Brace yourself as we embark on an exhilarating journey to understand the key differences between frameworks and libraries.

  * Picture this: You have a magnificent home, and you're looking to furnish it with style and efficiency. But wait! You don't want to start from scratch and build every piece of furniture yourself. That's where libraries and frameworks come to the rescue!
    
    - #### Libraries: Your Personal Shopping Spree at Ikea:
      - Imagine stepping into the wonderland of Ikea. You already have a home, but you need a little assistance in selecting the perfect furniture pieces. With libraries, you have the freedom to handpick various components and functionalities that seamlessly integrate into your existing code. It's like being the master of your domain, making choices that suit your specific needs. The power is in your hands!
    
    - #### Frameworks: Building the Architectural Marvel:
      - Now, picture yourself as a skilled architect, ready to construct a magnificent model home. You have a set of blueprints and some predefined design choices. Here's the twist: the contractor and blueprint take the lead. They guide you through the process, determining when and where you can contribute your creative input. The framework sets the rules, orchestrating the flow of your application. It's a collaboration where you work within the framework's structure, creating a masterpiece that aligns with its vision.

  * #### The Battle for Control: Inversion of Control:

    - Ah, the technical secret behind the curtain! The defining factor between frameworks and libraries lies in the concept of inversion of control.

    - Libraries grant you the freedom to take charge. You decide when and where to utilize their functionality, seamlessly integrating them into your code. It's like being the director of a grand theater production, calling upon specific library functions when the spotlight shines on them.

    - Frameworks, on the other hand, flip the script. They assume control of the flow. You become part of a grand symphony, plugging your code into predefined hooks and letting the framework conduct the performance. It's an enchanting dance where the framework takes the lead, executing your code as needed. Surrender to the framework's rhythm and let it weave its magic.

  ### Resources:

  Ready to embark on this epic journey? Dive deeper into the realm of frameworks and libraries at [FreeCode Camp ↗](https://www.freecodecamp.org/news/the-difference-between-a-framework-and-a-library-bd133054023f/). Let the adventure begin!

5. ## Unveiling the Magic of React: A Thrilling Journey
  ### Content:
  
  * #### Brace yourself for a mind-blowing exploration of React's Inner Workings!
   
    - Welcome, adventurous developers, to a captivating guide that will take you deep into the heart of React. Prepare to witness the hidden mechanisms that power this incredible web framework and discover how to unleash its true potential in your code.
  
  * #### Ignite Your Curiosity: Why Should You Care?
   
    - You may have already encountered some rules and guidelines while diving into the world of React. But have you ever wondered why these rules exist? By unraveling the secrets behind them, you'll gain a competitive edge and transform yourself into a React virtuoso.
  
  * #### Unleashing the Power of Keys
    - Behold, the magnificent keys that unlock React's full potential! When rendering a list of similar components using the map function, keys become your secret weapon. They provide React with the ability to identify changes more efficiently, without relying solely on the position of the elements.

    - Imagine the performance boost! React no longer needs to traverse the entire list for every diffing operation. With the power of keys, only the specific list item that has changed receives the spotlight, resulting in faster and more optimized rendering.
      
  ### Resources:
  Ready to embark on this thrilling expedition into the depths of React's inner workings? Dive into the exhilarating world of React's Inner Workings by visiting [Dev Des ↗](https://dev-des.hashnode.dev/unlocking-reacts-inner-workings-a-beginners-guide). Let the adventure begin!

6. ## Client-Side vs. Server-Side
  ### Content:
   
  * #### What is client-side development?
      
      - Client-side development, sometimes referred to as front-end development, is a type of development that involves programs that run on a client's or user's device. Client-side developers focus on creating the part of a website with which the user interacts.
      
      - This type of development focuses on the front part of an application that users can see. Client-side developers complete a variety of tasks, including:

        * Creating website layouts
      
        * Designing user interfaces
      
        * Adding form validation
      
        * Reviewing the performance of websites
      
        * Adding visual design elements like colors and fonts
      
        * Making website features more functional
      
        * Resolving any issues that users encounter on a site
      
        * It's mean do every thing in website, poor thing!😥
    
  * #### What is server-side development?
      
  - Server-side development, sometimes called back-end development, is a type of development that involves programs that run on a server. This type of programming is important because web browsers, or clients, interact with web servers to retrieve information. Users don't see this development because it happens on servers. Common server-side tasks include:

      * Coding dynamic websites
 
      * Developing web applications

      * Connecting websites to databases

      * Implementing content management systems

      * Making sure programs retrieve information properly

      * Ensuring systems are safe from hackers

      * Restoring and backing up files

  ### Resources:

7. ## Unleashing the Power of Client-Side Development: A Thrilling Ride
    
  ### Content:
  - #### Brace yourself for a thrilling exploration of the Advantages of Client-Side Development!
      Welcome, daring developers, to an exhilarating journey that will unveil the hidden treasures of client-side development. Get ready to witness the immense benefits that await those who dare to embrace this cutting-edge approach.
    
  - #### Reduced Server-Side Workload: Lightening the Burden
      Prepare to be amazed as we unveil the first advantage of client-side development: a significantly reduced server-side workload. By offloading complex operations and rendering tasks to the client-side, the server can breathe a sigh of relief. No longer burdened with heavy lifting, it can focus on delivering data and resources more efficiently.

  - #### The Power of Separation: Embracing the Law of Demeter
      Software developers always try to comply with the Law of Demeter, but when a common server-side language is used for both client-side and server-side rendering, it’s very easy to take shortcuts to loosely couple the two technologies. It makes sense, because when all the Java code is deployed to the same server with the same set of backend-resources at the ready, it’s just too easy for a JSF developer to quickly make a database call to get the necessary information rather than wait for another development team to create a RESTful service that does the same thing.
    
  - #### Unleashing Cost Efficiency: Saving the Day
      Prepare for a thrilling twist! Client-side development brings forth the advantage of reduced server-side costs. With lighter server workloads and optimized resource allocation, organizations can witness a significant reduction in infrastructure expenses. It's a win-win situation where both developers and stakeholders rejoice in the cost efficiency achieved.

  - #### Swift and Seamless: Easier Code Deployments
      In our adventure, we encounter a game-changing revelation: easier code deployments. With client-side development, the process of deploying code becomes a breeze. No longer bound by complex server configurations and dependencies, developers can swiftly release updates and enhancements. It's a seamless journey towards continuous deployment and a more agile development workflow.

  - #### Elevating the Client Experience: Rendering Marvels
      Hold your breath as we reach the pinnacle of client-side development: an unparalleled client experience. By harnessing the power of client-side rendering, users are treated to lightning-fast interactions and immersive interfaces. Say goodbye to the dreaded page reloads and hello to dynamic and responsive applications. It's a feast for the senses and a testament to the transformative power of client-side development.

  ### Resources:
  Ready to embark on this thrilling expedition into the world of client-side development? Dive into the depths of the Advantages of Client-Side Development by exploring the captivating [blog ↗](https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/Top-five-benefits-of-client-side-rendering#:~:text=Top%205%20benefits%20of%20client-side%20rendering%20frameworks%201,Client-side%20rendering%20means%20a%20better%20client%20experience%20). Let the adventure begin!


8. ## React's Rendering Mechanism:
  ### Content:
  - #### To understand why React is so fast it is important to know these four concepts:
      
      - Virtual DOM.
      The Virtual DOM was a strategy that appeared to solve the modifications or mutations that the DOM suffers when using a web or mobile application. Rendering the entire document tree is too costly as applications become more complex; by mutations, we can understand any change that the DOM can undergo: an insertion/modification/deletion of an element or its properties.

      Thus, the Virtual DOM came to represent the DOM tree in memory. Perform calculations using the state and props and finally decide which elements of the actual DOM (the browser one, I mean haha) should be mutated. [From the official React website](https://reactjs.org/docs/faq-internals.html):

          The virtual DOM (VDOM) is a programming concept where an ideal, or “virtual”, representation of a UI is kept in memory and synced with the “real” DOM by a library such as ReactDOM. This process is called reconciliation.    

      Initially, I said that the concept we normally know as rendering is different in React, I personally considered rendering as the procedure of synchronizing changes in the DOM. React synchronizes the changes in the DOM through three steps.
      
      ![EX.1](https://res.cloudinary.com/practicaldev/image/fetch/s--8w4-NrE6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/csjl5onhxu99qhokbfjh.png)
      
      - Render.
      Rendering is a process that is triggered by a change of state in some component of your application, when a state change occurs React:
      
      ![EX.2](https://res.cloudinary.com/practicaldev/image/fetch/s--rulaPxWd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/9s7jqpadoijq32y5b1eo.png)
      
      * It will collect from the root of your App all the components that requested a re-render because their state or their props changed.
        
      * It will invoke these components
        
        * If you use `function components` it will invoke the function itself, something `like Header(props)`.
        
        * If you use `class components` it will `invoke YourComponent.render()`.

      Even when the process's name is rendering, at this point, the DOM has not been modified or altered, which could be a little tricky if you think as I did, about the meaning of render.

      Since we normally use `JSX`, the code will be transformed to `React.createElement(...)`. The output of the `createElement` will describe how the application should look like in the next version of the render through the next stage called:

      - Reconciliation.
      Once the re-rendering has happened, React has the context of two versions of the `React.createElement` output, the version executed before the state change occurred, and the version executed after the state has changed.
      
      ![EX.3](https://res.cloudinary.com/practicaldev/image/fetch/s--WO9HqQdq--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/5b2efk1nj6yhl83jou5i.png)

      At this point two objects are describing the UI, React through a heuristic algorithm of order O(n^3) will be able to determine which elements need to be represented again.

      Among technical details the React team tells us some aspects about how React identifies which elements were affected:

      * Elements that changed type must be recreated.

      * Changes within the attributes of an element are replaced, without unmounting the element.

      * Upgrades within the element's children recreate all children

      * Updates within child elements that use `key` as attributes are compared and only new items are represented.

      - Commit.
      After React calculated all the changes that should be made in the application tree, `react-dom` appears for the browser and `react-native` for the mobile platforms, which make the modifications to the browser or mobile app API (finally! 🥳). Synchronously React will clean up the past layout effects, run the new layout effects, then the browser will paint the DOM, after that, React will clean up the past effects and mount the new ones; when I talk about effects I refer to the lifecycles method such as [useLayoutEffect](https://reactjs.org/docs/hooks-reference.html#uselayouteffect) and [useEffect](After React calculated all the changes that should be made in the application tree, react-dom appears for the browser and react-native for the mobile platforms, which make the modifications to the browser or mobile app API (finally! 🥳). Synchronously React will clean up the past layout effects, run the new layout effects, then the browser will paint the DOM, after that, React will clean up the past effects and mount the new ones; when I talk about effects I refer to the lifecycles method such as useLayoutEffect and useEffect.).

      ![EX.4](https://res.cloudinary.com/practicaldev/image/fetch/s--iWg-G05---/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/9pswc5zt2psdqbgiq8oa.png)
  
      To explain the lifecycles method part a little bit more, I bring to you this wonderful graph that Donavon West and his contributors created. This is the project [repo](https://github.com/donavon/hook-flow), check it out!

      ![EX.5](https://res.cloudinary.com/practicaldev/image/fetch/s--Gb81aRyw--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/rexqxdys2yzjq7m178ba.png)



  ### Resources:
    - To learn more visit [Dev.to](https://dev.to/mateo_garcia/understanding-rendering-in-react-i5i)
    - To learn react visit [React Docs](https://reactjs.org/docs/faq-internals.html)
